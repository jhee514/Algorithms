# Ad 대비 보충

## 190821

-   두문제 출제
    -   완전검색

        -   선형구조에서는 완전검색을 묻지 않아. 비선형구조자료형이 주로 출제

            -   비선형구조 대표적인 예가 ' 그래프 '

                -   물리적 관계
                -   논리적 관계

            -   순회

                -   DFS : 이거 엄청 잘하면 취득 가능성 엄청 높아져ㅕㅕㅕㅕㅕ

                    -   스택반복
                    -   재귀

                -   BFS

                    -   반복, 큐?

                        

    -   조합론으로 모든 경우의 수를 생성해야하는 경우

        -   순열, 부분집합, 조합
        -   반복문, 재귀
            -   백트래킹 => 상태공간트리 + 가지치기
        -   그렇구나아아아아아아아아아아아아아아

-   AD + 은 시뮬레이션

-   AD는 효율적으로 짤 생각을 하지를 마
  
    -   !!!!! 정답은 나온다 라는 마인드가 중요 !!!!!
-   결과가 바로 안나
-   아이디어, 디자인을 종이에 먼저 하고, 슈도코드 짜고, 코딩 => 노트 하나 만들어 놓으면 나중에 보면 ... 웃기겠지...



### DFS

-   비선형 자료를 모든 요소들을 빠짐 없이 중복 없이 검토 할 수 있는 방법
-   스택
    -   방문한 노드에 대해 자기처리 하고 해당 노드의 이웃 들을 조사를 해서 다음의 처리를 위해 자료를 저장하는데 이 때 저장하는 곳이 스택이거나 큐가 되는 것. 이 때 스택이 저장소가 되면 depth 가 되는 것이고 큐가 되면 broad 가 되는 것
    -   stack 에 처리가 필요한 이웃 노드 들을 차곡차곡 저장하고, isEmpty 를 통해서 처리 하지 않은 데이터가 있을 수 없게 함으로서 전체 검색을 하는 것. 
    -   이 때 방문처리한 애들은 스킵하기 위해 표시 하는 것이 visited
    -   나중에 스택 안쓰고 결국 재귀를 쓰게 될 것
-   재귀



## 190823

### BFS

-   가중치가 있는 간선의 경우는 불가능
-   무방향 가중치 없는 간선 판별에 적합



### Queue

-   Priority Queue? => 큐에 삽입할 때마다 sorting 을 해주면 priority 가 생기니까 속도가 빠르지
-   선입선출 구조
-   자기 처리 => 이웃처리 => 자기처리 => 이웃처리 stack 이 빌 때 까지 : 여기서 저장소가 stack 이나 queue 냐 차이
-   스택은 stack에서 꺼낸 다음 if not visited 일 때 처리한다.
-   큐에선 큐에 일단 출발점을 삽입 후 visited로 표시
-   친구의 친구를 찾는 문제는 깊이우선탐색은 안되고 넓이우선탐색으로 해야 단계별 레벨단위로 요소들을 확인하니까 적합



### etc.

-   python 에서는 ``append`` `pop` 정도는 써도 된다.
-   제어문을 너무 중첩중첩중첩 하는데 이걸 관두고 함수를 쪼개고 쪼개고 펼쳐서 쓰는 습관이 중요



## 190826

### backtracking

N 개에서 R 개를 뽑는다

순서가 있는 순열은 parameter 1개 필요, 순서가 없으면 depth를 알아야하니까 2개 필요



## 190902

### 부분집합

-   knapsack
    -   가치냐 무게냐
    -   이런 문제는 모든 부분집합의 경우를 다 봐야 풀 수 있어
-   요즘 문제는 가지치기 안해도 될만큼 depth 가 얕게 나와



## 190904

-   ``syt.stdout``
-   시간 측정

```python
import time
time.time
print(time.time()-st)
```



## 190917

-   순열

    -   swap 방식이 메모리 적게 필요

    ```python
    def perm(n, r)
    	if r == 0:
            print(t)
        else:
            for i in range(n-1, -1, -1):
                arr[i], arr[n-1] = arr[n-1], arr[i]
                t[r-1] = a[n-1]
                perm(n-1, r-1)
                arr[i], arr[n-1] = arr[n-1], arr[i]
                
    temp = [0] * n
    ```

    ```python
    visitied = [0] * n
    t = [0] * n
    def perm(k):
        if k == n:
            print(arr)
            else:
                for i in range(n):
                    if visited[i]:
                        continue
                        t[k] = a[i]
                        visited[i] = 1
                        perm(k+1)
                        visited[i] = 0
    ```

